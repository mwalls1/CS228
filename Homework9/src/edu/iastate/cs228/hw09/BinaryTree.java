package edu.iastate.cs228.hw09;import java.util.Iterator;import java.util.NoSuchElementException;import java.util.Stack;import java.util.LinkedList;/** *  * A class that implements the ADT binary tree. *  * @author Frank M. Carrano * @author Timothy M. Henry * @author Mason Walls *  *  * 		NOTEs and REQUIREMENTs: *  *         0. Put your Firstname and Lastname after above empty author tag. Make *         sure that in both cases the first letter is uppercase and all others *         are lowercase. 1. You are allowed to create and use your own private *         helper methods. If you are introducing your own helper methods those *         need to be private and properly documented as per Javadoc style, *         i.e., you are not allowed to have public helper method. Already *         existing methods declaration cannot be changed. 2. No additional data *         fields can be introduced in any of the classes below. You are not *         allowed to change the case of the ones already existing, or rename *         those. Except where it's explicitly mentioned that you are allowed. *         3. No custom classes of your own can be introduced or used. 4. Import *         statements are not allowed, besides the ones that are already *         provided. 5. Fully qualified class names usage is not allowed. 6. You *         are allowed to reuse any part of the provided source codes or shown *         under lecture notes section of Canvas, which do not violate any of *         above. 7. Check carefully the lecture notes of Week 10 named *         "treeImpls_part2.pdf" for hints (and partial solutions) for this HW's *         required parts. 8. If you have any additional questions PLEASE ask on *         Piazza Q/A platform, but first PLEASE search and make sure that it *         was not already asked and answered. PLEASE setup your notifications *         for both Canvas and Piazza so that you are updated whenever there are *         any changes immediately. 9. You need to provide implementation to all *         methods and constructors which have a comment //TODO in their body. *         For all of these methods and constructors there is no need to provide *         comments. (Latter part applies also for all provided *         classes/interfaces, including the constructors/methods which you are *         not required to implement as part of this HW.) 10.You can assume that *         data of each node of binary tree will never be null. *  *  */public class BinaryTree<T> implements BinaryTreeInterface<T> {	private BinaryNode<T> root;	public BinaryTree() {		root = null;	} // end default constructor	public BinaryTree(T rootData) {		root = new BinaryNode<>(rootData);	} // end constructor	public BinaryTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree) {		privateSetTree(rootData, leftTree, rightTree);	} // end constructor	public void setTree(T rootData) {		root = new BinaryNode<>(rootData);	} // end setTree	public void setTree(T rootData, BinaryTreeInterface<T> leftTree, BinaryTreeInterface<T> rightTree) {		privateSetTree(rootData, (BinaryTree<T>) leftTree, (BinaryTree<T>) rightTree);	} // end setTree	private void privateSetTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree) {		root = new BinaryNode<>(rootData);		if ((leftTree != null) && !leftTree.isEmpty())			root.setLeftChild(leftTree.root);		if ((rightTree != null) && !rightTree.isEmpty()) {			if (rightTree != leftTree)				root.setRightChild(rightTree.root);			else				root.setRightChild(rightTree.root.copy());		} // end if		if ((leftTree != null) && (leftTree != this))			leftTree.clear();		if ((rightTree != null) && (rightTree != this))			rightTree.clear();	} // end privateSetTree	public T getRootData() {		if (isEmpty())			throw new EmptyTreeException();		else			return root.getData();	} // end getRootData	public boolean isEmpty() {		return root == null;	} // end isEmpty	public void clear() {		root = null;	} // end clear	public void setRootData(T rootData) {		root.setData(rootData);	} // end setRootData	public void setRootNode(BinaryNode<T> rootNode) {		root = rootNode;	} // end setRootNode	public BinaryNode<T> getRootNode() {		return root;	} // end getRootNode	public int getHeight() {		return root.getHeight();	} // end getHeight	public int getNumberOfNodes() {		return root.getNumberOfNodes();	} // end getNumberOfNodes	public Iterator<T> getPreorderIterator() {		return new PreorderIterator();	} // end getPreorderIterator	public Iterator<T> getInorderIterator() {		return new InorderIterator();	} // end getInorderIterator	public Iterator<T> getPostorderIterator() {		return new PostorderIterator();	} // end getPostorderIterator	public Iterator<T> getLevelOrderIterator() {		return new LevelOrderIterator();	} // end getLevelOrderIterator	private class InorderIterator implements Iterator<T> {		private Stack<BinaryNode<T>> nodeStack;		private BinaryNode<T> currentNode;		public InorderIterator() {			nodeStack = new Stack<>();			currentNode = root;		} // end default constructor		public boolean hasNext() {			return !nodeStack.empty() || (currentNode != null);		} // end hasNext		public T next() {			BinaryNode<T> nextNode = null;			while (currentNode != null) {				nodeStack.push(currentNode);				currentNode = currentNode.getLeftChild();			}			if (!nodeStack.empty()) {				nextNode = nodeStack.pop();				assert nextNode != null;				currentNode = nextNode.getRightChild();			} else				throw new NoSuchElementException();			return nextNode.getData();		}	} // end InorderIterator	public void iterativeInorderTraverse() {		Stack<BinaryNode<T>> nodeStack = new Stack<>();		BinaryNode<T> currentNode = root;		while (!nodeStack.isEmpty() || (currentNode != null)) {			while (currentNode != null) {				nodeStack.push(currentNode);				currentNode = currentNode.getLeftChild();			}			if (!nodeStack.isEmpty()) {				BinaryNode<T> nextNode = nodeStack.pop();				assert nextNode != null;				System.out.print(nextNode.getData() + " ");				currentNode = nextNode.getRightChild();			}		}	} // end iterativeInorderTraverse	/**	 * Outputs exact same info as iterativeInorderTraverse() method but for preorder	 * traversal. You need to use Stack to implement this method iteratively.	 */	public void iterativePreorderTraverse() {		BinaryNode<T> current = root;		if (current == null)			return;		Stack<BinaryNode<T>> nodeStack = new Stack<BinaryNode<T>>();		nodeStack.push(root);		while (!nodeStack.isEmpty()) {			BinaryNode<T> temp = nodeStack.peek();			System.out.print(temp.getData() + " ");			nodeStack.pop();			if (temp.getRightChild() != null) {				nodeStack.push(temp.getRightChild());			}			if (temp.getLeftChild() != null) {				nodeStack.push(temp.getLeftChild());			}		}		return;	}	/**	 * Outputs exact same info as iterativeInorderTraverse() method but for	 * postorder traversal. You need to use Stack to implement this method	 * iteratively.	 */	public void iterativePostorderTraverse() {		Stack<BinaryNode> stack = new Stack<BinaryNode>();		while (root != null) {			stack.push(root);			root = root.getLeftChild();		}		BinaryNode node = null;		while (stack.size() > 0) {			boolean left = false; 			boolean right = false;			if (node != null && stack.peek().getLeftChild() == node) {				left = true;			} else if (node != null && stack.peek().getRightChild() == node) {				left = right = true;			}			node = stack.peek();			if (node.getLeftChild() != null && !left) {				stack.push(node.getLeftChild());			} else if (node.getRightChild() != null && !right) {				stack.push(node.getRightChild());			} else {				node = stack.pop();				System.out.print(node.getData() + " ");			}		}	}	/**	 * Outputs exact same info as iterativeInorderTraverse() method but for	 * levelorder traversal. You need to use Queue to implement this method	 * iteratively. Simulate Queue using LinkedList.	 * 	 */	public void iterativeLevelorderTraverse() {		LinkedList<BinaryNode<T>> queue = new LinkedList<>();		if (root != null) {			queue.add(root);			while (!queue.isEmpty()) {				root = queue.remove();				if (root.getLeftChild() != null) {					queue.add(root.getLeftChild());				}				if (root.getRightChild() != null) {					queue.add(root.getRightChild());				}				System.out.print(root.getData() + " ");			}		}	}	private class PreorderIterator implements Iterator<T> {		// You are allowed to create no more than		// 2 data fields in this class.		Stack<BinaryNode<T>> nodeStack;		public PreorderIterator() {			nodeStack = new Stack<BinaryNode<T>>();			if (root != null)				nodeStack.push(root);		}		public boolean hasNext() {			return !nodeStack.isEmpty();		}		public T next() {			BinaryNode<T> nextNode;			if (hasNext()) {				nextNode = nodeStack.pop();				if (nextNode.getRightChild() != null)					nodeStack.push(nextNode.getRightChild());				if (nextNode.getLeftChild() != null)					nodeStack.push(nextNode.getLeftChild());			} else {				throw new NoSuchElementException();			}			return nextNode.getData();		}	} // end PreorderIterator	private class PostorderIterator implements Iterator<T> {		// You are allowed to create no more than		// 2 data fields in this class.		Stack<BinaryNode<T>> nodeStack = new Stack<BinaryNode<T>>();		BinaryNode<T> current;		public PostorderIterator() {			current = root;		}		public boolean hasNext() {			return (!nodeStack.isEmpty() || current != null);		}		public T next() {			boolean found = false;			BinaryNode<T> nextNode, parentNode;			while (current != null) {				nodeStack.push(current);				if (current.getLeftChild() == null) {					current = current.getRightChild();				} else					current = current.getLeftChild();			}			if (!nodeStack.isEmpty()) {				nextNode = nodeStack.pop();				if (!nodeStack.isEmpty()) {					parentNode = nodeStack.peek();					if (nextNode.equals(parentNode.getLeftChild())) {						current = parentNode.getRightChild();					} else						current = null;				} else					current = null;			} else				throw new NoSuchElementException();			return nextNode.getData();		}	} // end PostorderIterator	private class LevelOrderIterator implements Iterator<T> {		// You are allowed to create no more than		// 2 data fields in this class.		LinkedList<BinaryNode<T>> queue;		public LevelOrderIterator() {			queue = new LinkedList<BinaryNode<T>>();			queue.add(root);		}		public boolean hasNext() {			return !queue.isEmpty();		}		public T next() {			if (hasNext()) {				BinaryNode<T> current = queue.remove();				if (current.getLeftChild() != null) {					queue.add(current.getLeftChild());				}				if (current.getRightChild() != null) {					queue.add(current.getRightChild());				}				return current.getData();			}			throw new NoSuchElementException();		} // end LevelOrderIterator	}}// end BinaryTree