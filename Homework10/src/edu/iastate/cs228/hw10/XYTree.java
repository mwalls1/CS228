package edu.iastate.cs228.hw10;/** * A class that implements an xy-tree. *  * @author Mason Walls *  *  *  *  *         NOTEs and REQUIREMENTs: *  *         0. Put your Firstname and Lastname after above empty author tag. Make *         sure that in both cases the first letter is uppercase and all others *         are composed of lowercase letters. *  *         1. You are allowed to create and use your own private helper methods. *         If you are introducing your own helper methods those need to be *         private ONLY and properly documented as per Javadoc style. Provided *         constructors/methods declarations cannot be changed. *  *         2. No additional data fields can be introduced in the class below. Or *         any other class provided as part of this HW. You are not allowed to *         change the case of the already existing data fields, or rename those. *  *         3. No custom classes of your own can be introduced or used. *  *         4. Import statements are not allowed. *  *         5. Fully qualified class names usage is not allowed. Exception is for *         levelOrderTraverse method ONLY, where you are allowed to use ONLY *         java.util.LinkedList class. *  *         6. You are allowed to reuse any part of the provided source codes or *         shown under lecture notes section of Canvas, which do not violate any *         of the requirements. *  *         7. If you have any additional questions PLEASE ask on Piazza Q/A *         platform, however, before posting a question PLEASE, first, search *         the Q/A platform to see if the same question was not already asked *         and answered. PLEASE setup your notifications for both Canvas and *         Piazza so that you are updated, immediately, whenever there are any *         changes happen either on Canvas or Piazza Q/A platform. *  *         8. You need to provide implementation to all methods which have a *         comment //TODO in their body. In this HW there 3 of those, i.e., *         addPoint, contains, and leverlOrderTraverse. For all of these methods *         there is no need to provide comments. Same, i.e., no comments, *         applies also for all provided classes/interfaces, including their *         constructors/methods which you are not required to implement as part *         of this HW. *  *         9.You can assume that x and y values of every Point will always be *         int values. *  *  */public class XYTree<T extends java.awt.Point> implements TreeInterface<T> {	private BinaryNode<T> root;	public XYTree() {		root = null;	}	public XYTree(T rootData) {		if (rootData != null)			root = new BinaryNode<>(rootData);		else			throw new IllegalArgumentException();	}	public void addAllPoints(T[] entries) {		if (entries == null || entries.length == 0)			throw new IllegalArgumentException();		for (T t : entries)			addPoint(t);	}	/**	 *	 * Adds a new point into the xy-tree if it does not exist in this tree. Check an	 * example under Canvas. Also, check the comment of levelOrderTraverse.	 * 	 */	public void addPoint(T anEntry) {		if (anEntry == null)			throw new IllegalArgumentException();		if (root == null) {			root = new BinaryNode<T>(anEntry);			return;		}		if (contains(anEntry))			return;		int currentLevel = 0;		BinaryNode<T> current = root;		while (current != null) {			if (currentLevel % 2 == 0) {				if (current.getData().getX() < anEntry.getX()) {					if (!current.hasRightChild()) {						current.setRightChild(new BinaryNode<T>(anEntry));						return;					} else {						currentLevel++;						current = current.getRightChild();					}				} else {					if (!current.hasLeftChild()) {						current.setLeftChild(new BinaryNode<T>(anEntry));						return;					} else {						currentLevel++;						current = current.getLeftChild();					}				}			} else {				if (current.getData().getY() < anEntry.getY()) {					if (!current.hasRightChild()) {						current.setRightChild(new BinaryNode<T>(anEntry));						return;					} else {						currentLevel++;						current = current.getRightChild();					}				} else {					if (!current.hasLeftChild()) {						current.setLeftChild(new BinaryNode<T>(anEntry));						return;					} else {						currentLevel++;						current = current.getLeftChild();					}				}			}		}		// TODO		return;	}	/**	 * Returns true if a point exists in this tree, otherwise false.	 * 	 */	public boolean contains(T anEntry) {		if (anEntry == null)			throw new IllegalArgumentException();		if (root == null)			return false;		int currentLevel = 0;		BinaryNode<T> current = root;		while (current != null) {			if (current.getData().equals(anEntry))				return true;			if (currentLevel % 2 == 0) {				if (current.getData().getX() < anEntry.getX()) {					current = current.getRightChild();					currentLevel++;				} else {					current = current.getLeftChild();					currentLevel++;				}			} else {				if (current.getData().getY() < anEntry.getY()) {					current = current.getRightChild();					currentLevel++;				} else {					current = current.getLeftChild();					currentLevel++;				}			}		}		return false;	}	/**	 * Returns a list of points in level-order traversal. In this method you are	 * allowed to use java.util.LinkedList class.	 * 	 * 	 * For example,	 * 	 * XYTree<Point> xy = new XYTree<>();	 * 	 * xy.addAllPoints(new Point[]{ new Point(5, 3), new Point(5, 2), new Point(10,	 * 7), new Point(9, 1), new Point(6, 8), new Point(6, 8), new Point(10, 1) });	 * System.out.println(xy.levelOrderTraverse());	 * 	 * would print	 * 	 * [(5, 3), (5, 2), (10, 7), (9, 1), (6, 8), (10, 1)]	 * 	 */	public java.util.LinkedList<String> levelOrderTraverse() {		// TODO		java.util.LinkedList<BinaryNode<T>> queue = new java.util.LinkedList<BinaryNode<T>>();		java.util.LinkedList<String> temp = new java.util.LinkedList<String>();		queue.add(root);		while (!queue.isEmpty()) {			BinaryNode<T> tempNode = queue.remove();			temp.add("(" + tempNode.getData().x + ", " + tempNode.getData().y + ")");			if (tempNode.hasLeftChild()) {				queue.add(tempNode.getLeftChild());			}			if (tempNode.hasRightChild()) {				queue.add(tempNode.getRightChild());			}		}		return temp;	}	@Override	@SuppressWarnings("unchecked")	public T getRootData() {		if (isEmpty())			throw new RuntimeException("Empty Tree!");		else			return (T) root.getData().clone();	}	@Override	public boolean isEmpty() {		return root == null;	}	@Override	public void clear() {		root = null;	}	@Override	public int getHeight() {		return root.getHeight();	}	@Override	public int getNumberOfNodes() {		return root.getNumberOfNodes();	}}